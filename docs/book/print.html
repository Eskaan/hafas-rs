<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>hafas-rs documentation</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="about.html"><strong aria-hidden="true">1.</strong> About</a></li><li class="chapter-item expanded "><a href="goals.html"><strong aria-hidden="true">2.</strong> Goals</a></li><li class="chapter-item expanded "><a href="structure.html"><strong aria-hidden="true">3.</strong> Structure</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="hafas-wrap.html"><strong aria-hidden="true">3.1.</strong> hafas_wrap</a></li><li class="chapter-item expanded "><a href="database-cli.html"><strong aria-hidden="true">3.2.</strong> database_cli</a></li></ol></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">4.</strong> Installation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="usage.html"><strong aria-hidden="true">4.1.</strong> Usage</a></li></ol></li><li class="chapter-item expanded "><a href="hafas.html"><strong aria-hidden="true">5.</strong> HAFAS & DB</a></li><li class="chapter-item expanded "><a href="future.html"><strong aria-hidden="true">6.</strong> Future</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">hafas-rs documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/eskaan/hafas-rs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="hafas-rs"><a class="header" href="#hafas-rs">HAFAS-RS</a></h1>
<h3 id="development-of-a-program-written-in-rust-to-query-deutsche-bahn-data"><a class="header" href="#development-of-a-program-written-in-rust-to-query-deutsche-bahn-data">Development of a program written in Rust to query &quot;Deutsche Bahn&quot;-data</a></h3>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<p>The <a href="https://www.bahn.de/">Deutsche Bahn AG</a> (abbreviated DB) is the German national railway company. As DB is
one of the largest transport companies of the world and the largest railway operator in
Europe (according to <a href="https://web.archive.org/web/20170927052239/http://www.railway-technology.com/features/featureengines-of-trade-the-ten-biggest-rail-companies-by-revenue-4943955/featureengines-of-trade-the-ten-biggest-rail-companies-by-revenue-4943955-1.html">this</a> source), a complex network of time schedules, trains and routes in Germany and other
European countries has to be organized. To facilitate the online journey planner for
customers the Software <a href="https://de.wikipedia.org/wiki/HAFAS">HAFAS</a> (HaCon Fahrplan-Auskunfts-System) of the company HaCon
(Hannover Consulting, belonging to Siemens) is used. 
<a href="https://www.rust-lang.org/">Rust</a> is a general-purpose programming language with outstanding performance and safety.
It doesnâ€™t require the use of a garbage collector or reference counting to ensure memory
safety. Rust can be used for systems programming whilst also offering high-level features.
For example, programs can be created with Rust to draw data from different software e.g.
HAFAS.</p>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<p>The recommended way to access the documentation is through the generated HTML version in the docs folder.
There is both <code>rustdoc</code> as <code>mdbook</code> documentation on this project, found in the <code>docs</code> folder.</p>
<ul>
<li><a href="https://eskaan.github.io/hafas-rs/rustdoc/database_cli/index.html">Rustdoc</a></li>
<li><a href="https://eskaan.github.io/hafas-rs/book/">[en] Book</a></li>
<li><a href="https://eskaan.github.io/hafas-rs/book-de/">[de] Book</a></li>
</ul>
<h2 id="about-the-project"><a class="header" href="#about-the-project">About the project</a></h2>
<p>The purpous of this project named HAFAS-RS, done for a high school presentation (GFS) by Adrian Struwe 
(<a href="https://github.com/eskaan">Eskaan</a>), was to develop a program to collect and list targeted data on trips, train types, locations and operators of the Deutsche Bahn.</p>
<p>It is currently licenced under the <a href="https://www.gnu.org/licenses/gpl-3.0.txt">GPL3</a> licence, allowing open distribution and modification of the code.
The project is fully documented, both in source code (per <a href="doc.rust-lang.org/rustdoc">rustdoc</a>) as in this [mdbook].</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="goals"><a class="header" href="#goals">Goals</a></h1>
<h2 id="goals-1"><a class="header" href="#goals-1">Goals</a></h2>
<p>The primary goal of the project was to extract data, e.g. the most used stations, and display them in a database.</p>
<p>Another goal was to query and compare train schedules to realtime data. 
Sadly, after many experiments I realized this API was designed to resist such data collection attempts. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project-structure"><a class="header" href="#project-structure">Project structure</a></h1>
<h2 id="general-structure"><a class="header" href="#general-structure">General structure</a></h2>
<p>The project is split into two main parts: </p>
<ul>
<li>
<p><a href="./hafas-wrap.html">hafas-wrap</a>, the library to access the HAFAS<sup class="footnote-reference"><a href="#hafas">1</a></sup>.</p>
<p>It provides simple ways to access the HAFAS through multiple methods 
and a generic type system which also supports custom request and response types out of the common usage.</p>
</li>
<li>
<p><a href="./database-cli.html">database-cli</a> that uses data queried through the library and injects certain parts into a postgresql database for further processig. </p>
<p>It currently also contains the subcommands to print a diagram showing the most used stations in the database. 
<strong>If you are searching about how to use this project, you will have to look here.</strong></p>
</li>
</ul>
<p>Most of the project, although not all, is written in a more procedural style, as this program is based on a cli and corresponding library. 
There are more object oriented parts in the library.</p>
<h2 id="further-documentation"><a class="header" href="#further-documentation">Further documentation</a></h2>
<p>Each of those projects contain their own <code>README.md</code> file further explaining their use.</p>
<p>I also recommend using the rust-doc documentation for the project-level documentation, to be found in the <code>docs/rustdoc</code> folder <a href="/rustdoc/database_cli/index.html"><code>./docs/rustdoc/database_cli/index.html</code></a>.</p>
<div class="footnote-definition" id="hafas"><sup class="footnote-definition-label">1</sup>
<p>Hacon Fahrplan Auskunfts System</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-hafas_wrap-library"><a class="header" href="#the-hafas_wrap-library">The hafas_wrap library</a></h1>
<p>The main functionality comes with the <code>Client</code> object, as all requests are done with it.</p>
<p>This library also provides some <a href="hafas-wrap.html#hafas-profiles"><code>hafas_profiles</code></a> for common endpoints and <a href="hafas-wrap.html#methods">request and response structs</a> to simplify the working with HAFAS endpoints.
The <a href="hafas-wrap.html#utils"><code>util</code></a> module provides functions to de- and encode Base64-AES Strings using a statically set key and a md5 hashing function needed for requests.</p>
<h2 id="the-request-function"><a class="header" href="#the-request-function">The request function</a></h2>
<p>It provides a simple, through customisable system to access the HAFAS<sup class="footnote-reference"><a href="#hafas">1</a></sup>.
There are three common request parameters:</p>
<pre><code class="language-rust ignore">    pub async fn request&lt;I: Serialize + Sized, O: DeserializeOwned&gt;(
        &amp;self,
        profile: &amp;HafasProfile,
        requests: Vec&lt;RawHafasRequest&lt;I&gt;&gt;,
    ) -&gt; Result&lt;Vec&lt;O&gt;, RequestError&gt; {</code></pre>
<ul>
<li>
<p>A reference to it<code>self</code>, to access the <a href="https://crates.io/crates/reqwest">reqwest</a> request client used to make web requests</p>
</li>
<li>
<p>A reference to an instance of the <code>HafasProfile</code> type</p>
<p>A <code>HafasProfile</code> specifies the endpoint, possible encryption and additional config data that have to be passed on with the request</p>
</li>
<li>
<p>An array containing instances of the <code>RawHafasRequest</code> type</p>
<p>The <code>RawHafasRequest</code> type (and it's request generic) have to implement <code>serde::Serialize + Send</code>. 
These implementations are needed for the type to be serialized to a JSON string, used in the POST request to HAFAS<sup class="footnote-reference"><a href="#hafas">1</a></sup>.</p>
</li>
</ul>
<p>The <code>request</code> function also tries to parse the resulting request bodies into the specified generic type <code>O</code>. 
This type has to implement <code>DeserializeOwned</code> so it can be deserialized from a JSON object. </p>
<h2 id="request-procedure"><a class="header" href="#request-procedure">Request procedure</a></h2>
<p>There are two methods of requesting data: Either <code>request</code> or <code>request_raw</code>, 
where <code>request</code> is mainly a wrapper around the <code>request_raw</code> method to make parsing of the results easier.</p>
<p>Here is a summary of what the functions do:</p>
<p>Both:</p>
<ol>
<li>
<p>Clone the <code>HafasProfile</code> into a JSON object,</p>
<p>Serialize the requests into a JSON object and set the <code>svcReqL</code> value of the request to it. </p>
<p>Serialize the JSON object into a String</p>
<pre><code class="language-rust ignore">     let mut req_values = profile.config.clone();
     req_values[&quot;svcReqL&quot;] = serde_json::to_value(&amp;requests).unwrap();
     let req_string = serde_json::to_string(&amp;req_values)?;</code></pre>
</li>
<li>
<p>Optionally create a checksum for the GET parameters of the request.</p>
<pre><code class="language-rust ignore">     let checksum = match &amp;profile.secret {
         Some(secret) =&gt; util::hash_md5(&amp;(req_string.clone() + secret)),
         None =&gt; String::new(),
     };</code></pre>
</li>
<li>
<p>Create, send and wait for the response text of a web request to HAFAS<sup class="footnote-reference"><a href="#hafas">1</a></sup>.</p>
<pre><code class="language-rust ignore">     let response = self
         .reqwest_client
         .post(profile.url)
         .header(&quot;Accept&quot;, &quot;application/json&quot;)
         .header(&quot;Content-Type&quot;, &quot;application/json&quot;)
         .query(&amp;[(&quot;checksum&quot;, &amp;checksum)])
         .body(req_string)
         .send()
         .await?;</code></pre>
</li>
</ol>
<p><code>request_raw</code> at this point returns the response String, whilst <code>request</code> continues with parsing the response:</p>
<p>Only <code>request</code>:</p>
<ol start="5">
<li>
<p>Checks if HAFAS<sup class="footnote-reference"><a href="#hafas">1</a></sup> returned an error message.</p>
<pre><code class="language-rust ignore">     if res.get(&quot;err&quot;) != Some(&amp;Value::String(String::from(&quot;OK&quot;))) {
         return Err(RequestError::InternalError(
             res.get(&quot;err&quot;)</code></pre>
</li>
<li>
<p>Deserializes the request to a JSON object and then tries to get the response body segment as an array.</p>
<pre><code class="language-rust ignore">     res.get(&quot;svcResL&quot;)
         .ok_or(RequestError::DeserializeError(
             &quot;Response not an Object or svcResL does not exist in it.&quot;,
         ))?
         .as_array()
         .ok_or(RequestError::DeserializeError(&quot;svcResL is not an array.&quot;))?</code></pre>
</li>
<li>
<p>Deserializes the array of JSON objects into the specified generic type <code>O</code></p>
<pre><code class="language-rust ignore">         .iter()
         .map(|r| {
             Ok(serde_json::from_value(
                 r.get(&quot;res&quot;)
                     .ok_or(RequestError::DeserializeError(
                         &quot;field res does not exist. This is most likely a request error.&quot;,
                     ))?
                     .clone(),
             )?)
         })
         .collect::&lt;Result&lt;Vec&lt;O&gt;, RequestError&gt;&gt;()</code></pre>
</li>
</ol>
<h2 id="hafas-profiles"><a class="header" href="#hafas-profiles">HAFAS Profiles</a></h2>
<p>In the <code>hafas_profiles</code> module, you can find multiple config presets for different HAFAS<sup class="footnote-reference"><a href="#hafas">1</a></sup> endpoints. </p>
<p>These were collected from different other open source projects.</p>
<h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<p>In the <code>methods</code> module, you can find some Request and Response struct presets. You do not have to use these, but they have been tested and seem to work.</p>
<p>Current available methods:</p>
<ul>
<li>HimSearch</li>
<li>JourneyMatch</li>
<li>JourneyDetail</li>
</ul>
<h2 id="utils"><a class="header" href="#utils">Utils</a></h2>
<p>Some miscellaneous functions like ones to AES-Encrypt with a set key or to hash a String using the <code>md5</code> digest algorithm. </p>
<div class="footnote-definition" id="hafas"><sup class="footnote-definition-label">1</sup>
<p><a href="https://de.wikipedia.org/wiki/HAFAS">Hacon Fahrplan Auskunfts System</a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-database-cli-toolchain"><a class="header" href="#the-database-cli-toolchain">The database-cli toolchain</a></h1>
<p>This is currently the only implementation of the aforementioned library.</p>
<p>The current use is to create a database of trips, train types, locations and operators. 
For the exact layout, see <code>database_layout.png</code> at the root of the project.
You can also create a simple diagram from usage statistics.</p>
<p>Although the program does not need a live database to compile, it will need a postgres database to function.
The database has to be on localhost, with the name <code>db-statistics</code> and the user <code>postgres</code> (password-less) 
being able to access all tables specified in the database layout. 
To prepare the database for use, run <code>database-cli migrate</code>. This will create all necessary schemas, tables, types and functions.</p>
<p>For the exact usage, refer to the rustdoc documentation of the [<code>main</code>] method or the usage section in the book.</p>
<p>This crate is mostly written in a more procedural (althrough object-oriented) programming style, as common for a cli interface to a library.
This results in many modules which mostly contain single functions instead of entire objects. </p>
<p>For this module-level I highly recommend the rust-doc documentation for this crate available <a href="./databasecli/index.html">here</a></p>
<p>For better structured information on the cli commands, see the <a href="./usage.html">usage section</a> of this book.</p>
<h2 id="main"><a class="header" href="#main">Main</a></h2>
<p>This is the root module of the crate, here lies the function that is called on program start. This module parses the cli arguments and calls the corresponding functions.</p>
<h2 id="request_raw_jids"><a class="header" href="#request_raw_jids">request_raw_jids</a></h2>
<p>This module is responsible for the <code>data request_raw</code> subcommand. It requests raw data from HAFAS and writes it to the <code>raw_data</code> table.</p>
<h2 id="parse_raw_jids"><a class="header" href="#parse_raw_jids">parse_raw_jids</a></h2>
<p>This module gets called from the <code>data parse</code> subcommand and parses data from the <code>raw_data</code> and inserts it into the other tables <code>trips</code>,<code>locations</code>,<code>operators</code> and <code>train_types</code>.</p>
<h2 id="count_location_trips"><a class="header" href="#count_location_trips">count_location_trips</a></h2>
<p>This module is an extension to the <code>data parse</code> subcommand, called by using <code>dara parse_heatmap</code>.</p>
<h2 id="compare_raw_data"><a class="header" href="#compare_raw_data">compare_raw_data</a></h2>
<p>This module is called from the <code>data check</code> subcommand. It uses the request_raw_jids module to request a single jid and compare it to the <code>raw_data</code> table.</p>
<h2 id="create_heatmap_diagram"><a class="header" href="#create_heatmap_diagram">create_heatmap_diagram</a></h2>
<p>This module contains the only practical use, I have found yet, besides toying with database data. It is called by the <code>create_heatmap</code> subcommand and creates a horizontal chart diagram displaying the most used stations in the database.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<p>This program depends on:</p>
<ul>
<li>A running <a href="https://www.postgresql.org/">Postgresql</a> server on <code>postgres://postgres@localhost/db-statistics</code> <br>
Tested with Postgresql 13</li>
<li><a href="https://www.rust-lang.org/">Rust</a> stable</li>
<li>A working internet connection</li>
</ul>
<h2 id="quick-starter-guide"><a class="header" href="#quick-starter-guide">Quick starter guide</a></h2>
<p>Disclaimer: Most of this guide only works on Linux, you may refer to the <a href="https://www.postgresql.org/docs/current/">Postgresql documentation</a> and the <a href="https://www.rust-lang.org/">Rust</a> website for more information on other systems.</p>
<ol>
<li>Firstly, you have to install <a href="https://www.postgresql.org/">postgresql</a>:
<ol>
<li>Install the database package on your system:
<ul>
<li>Arch: <code>sudo pacman -S postgresql</code></li>
<li>Debain &amp; Ubuntu: <code>sudo apt install postgresql</code></li>
<li>Other: <a href="https://www.postgresql.org/docs/current/tutorial-install.html">Postgresql install guide</a></li>
</ul>
</li>
<li>Then, login into the newly created user: <code>sudo su postgres</code>.</li>
<li>Create a new database cluster using <code>initdb -D directory/to/store/data</code>.</li>
<li>Start the Postgresql server (usually <code>sudo systemctl start postgresql</code>).</li>
<li>Create a new database in the cluster named db-statistics in the cluster: <code>createdb db-statistics</code>.</li>
</ol>
</li>
<li>Compile the project:
<ol>
<li>Install the rustup package:
<ul>
<li>Arch: <code>sudo pacman -S rustup</code></li>
<li>Debial &amp; Ubuntu: <code>sudo apt install rustup</code></li>
<li>Other: <a href="https://rustup.rs/">Rustup install guide</a></li>
</ul>
</li>
<li>Run <code>rustup install stable</code> in your terminal.</li>
<li>Run <code>cargo build --release</code> in the hafas-rs folder.
This should create a folder named <code>target/release</code> that contains an executable named <code>database-cli</code>.
Congratulations, you just successfully compiled the project!</li>
</ol>
</li>
<li>Then use <code>database-cli migrate</code> to check the connection to the local database and create neccessary infrastructure like schemas, tables and functions.</li>
<li>Use <code>database-cli data request_raw --parse</code> To request data and parse it into the database. 
This will take a while for all ~1.5 Million entries to be fetched.
I recommend running this command over night and at other times the system is not under heavy load.</li>
<li>You are ready to play with the data in your favourite SQL prompt! See the <a href="./hafas.html">HAFAS Section</a> for more information on the database structure.</li>
</ol>
<p>(Optional)</p>
<ol start="6">
<li>
<p>Use <code>database-cli data parse_heatmap</code> to parse trip's eva counts into a lighter format.</p>
</li>
<li>
<p>Use <code>database-cli create_heatmap -m 10</code> to get a diagram of the 10 most used stations.</p>
<p>After following these steps, the program should create an image named <code>heatmap.svg</code> in the current folder. Here is an example for it:
<img src="./images/heatmap.svg" alt="Heatmap diagram" /></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usage"><a class="header" href="#usage">Usage</a></h1>
<p>As the name of the crate already suggests, <code>database-cli</code> compiles into a command line interface.
This interface works together with a postgresql database to store and request HAFAS data.</p>
<h2 id="list-of-sub-commands"><a class="header" href="#list-of-sub-commands">List of sub-commands:</a></h2>
<p>All commands can be passed -v or -vv to make them more verbose.
You can add the <code>--help</code> argument to any subcommand to see details about the arguments.
If you do not want to compile the cli, refer to the source code for arguments.</p>
<details>
<summary>Responsible code in `main.rs`</summary>
<pre><code class="language-rust ignore">    // Setup clap with subcommands
    let mut cmd = command!(&quot;Hafas Scraping Database Tools&quot;)
        .arg(arg!(-v --verbose... &quot;Verbose output. Specify twice for trace mode&quot;))
        .arg(arg!(-q --quiet &quot;Only print on error and warnings&quot;))
        .subcommands(&amp;[
            command!(&quot;data&quot;)
                .about(&quot;Lookup and schedule data management&quot;)
                .subcommands(&amp;[
                    command!(&quot;request_raw&quot;)
                        .about(&quot;Request raw schedule data&quot;)
                        .args(&amp;[
                            arg!(&lt;TO&gt; &quot;Stop at jid&quot;).value_parser(value_parser!(usize)),
                            arg!([FROM] &quot;Begin with jid, defaults to 0&quot;)
                                .value_parser(value_parser!(usize)),
                            arg!(-u --update &quot;Also request existing entries&quot;),
                            arg!(-c --continue &quot;Continue at current highes jid&quot;),
                            arg!(-p --parse &quot;Synchronously parse using `data parse`&quot;),
                            arg!(-s --&quot;chunk-size&quot; &lt;SIZE&gt; &quot;Chunk size of requests. Defaults to 100&quot;).value_parser(value_parser!(usize)),
                        ]),
                        command!(&quot;parse&quot;)
                            .about(&quot;Parse raw data to schedule and stop data.&quot;)
                            .args(&amp;[
                                arg!([FROM] &quot;Begin with jid, defaults to 0&quot;).value_parser(value_parser!(i32)),
                                arg!([TO] &quot;Stop at jid&quot;).value_parser(value_parser!(i32)),
                                arg!(-s --&quot;chunk-size&quot; &lt;SIZE&gt; &quot;Chunk size of requests. Defaults to 100&quot;).value_parser(value_parser!(i32)),
                        ]),
                        command!(&quot;parse_heatmap&quot;)
                            .about(&quot;Parse trip data to heatmap counts.&quot;),
                        command!(&quot;check&quot;)
                        .about(&quot;Check if a single jid is different to the remote data.&quot;).arg(arg!(&lt;jid&gt; &quot;jid to check on&quot;).value_parser(value_parser!(usize))),
                ]),
                command!(&quot;create_heatmap&quot;)
                .about(&quot;Create heatmap diagram from parsed data.&quot;)
                .args(&amp;[
                    arg!([FILE] &quot;Output file to use. Defaults to ./heatmap.svg&quot;),
                    arg!(-m --max &lt;SIZE&gt; &quot;Maximum entries to display&quot;).value_parser(value_parser!(usize)),
                    arg!(-c --&quot;filter-cat-code&quot; &lt;CAT_CODE&gt; &quot;Filter results by cat code&quot;).value_parser(value_parser!(u8)),
                    arg!(-o --&quot;filter-cat-out&quot; &lt;CAT_OUT&gt; &quot;Filter results by cat out (f.e. RE, ICE)&quot;),
                    arg!(-s --&quot;limit-search&quot; &lt;SIZE&gt; &quot;Maximum search results to query&quot;).value_parser(value_parser!(i64)),
                ]),
            //command!(&quot;status&quot;).about(&quot;Query database status&quot;),
            command!(&quot;migrate&quot;).about(&quot;Migrate/create database&quot;),
        ]);</code></pre>
</details>
<ul>
<li>
<p><code>data</code> This command can only be used together with one of it's subcommands, it does not have any properties to it's own.
It generally collects commands that are used to move lookup data for train trips on the database.</p>
<ul>
<li>
<p><code>request_raw</code>: This command requests raw schedule data over all jids in the HAFAS endpoint. 
Independently of the <code>TO</code> argument, the command will panic if it reaches the last jid.
The ususal last jid is around 1.5 Million.</p>
<p>This is usually the second command ran after <code>migrate</code>.</p>
<p>Be aware that, depending on your computer and network connection, this command usually takes quite a long time to finish.
It is recommended, although not necessary, to invoke it with <code>--parse</code>.</p>
<p>It is recommended to leave all other optional flags to a default value to prevent a timeout.</p>
</li>
<li>
<p><code>parse</code>: This command parses the data from the <code>raw_data</code> table to a usable format and inserts it into the other tables. 
It can also be called automatically by adding <code>--parse</code> to the arguments of <code>request_raw</code>.</p>
<p>You may look at the database scheme and mainly the <a href="./hafas.html">hafas section</a> for more details about how data gets parsed.</p>
</li>
<li>
<p><code>parse_heatmap</code>: This command is a command that should be called at some time before using the <code>create_heatmap</code> feature. 
It counts together all of the recorded train trips into their own table for faster access.</p>
<p>As near and local trafic can obfuscate the ending image, I recommend setting <code>-o 'ICE'</code> as filter.</p>
</li>
<li>
<p><code>check</code>: This command checks if data from the HAFAS endpoint differs from the current data. 
This check is only done for a single jid. A difference might hint at a schedule change.</p>
</li>
</ul>
</li>
<li>
<p><code>create_heatmap</code> Creates a horizontal bar diagram of the most used stations in the lookup table. 
It can be filtered by cat_code, cat_out and search limit. For currently unknown reasons, anything over 11 Bars will mess up the station names.</p>
</li>
<li>
<p><code>migrate</code>: Creates all necessary infrastructure on the remote database. The cli itself currently only operates on the lookup_data schema, but this <code>sqlx</code> feature needs </p>
</li>
</ul>
<p>Most of the commands will result in a progress bar like this:
<img src="./images/progress_bar.png" alt="Progress-Bar" /><br>
The counts at the end should give you a rough hint on how long the command will take.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hafas-and-database-layout"><a class="header" href="#hafas-and-database-layout">HAFAS and Database layout</a></h1>
<h2 id="database-layout"><a class="header" href="#database-layout">Database Layout</a></h2>
<p><img src="./images/db_layout.png" alt="Layout" /></p>
<details>
<summary>DDL for Database Layout - click to expand</summary>
<pre><code class="language-sql">CREATE SCHEMA lookup_data;

CREATE TABLE lookup_data.raw_data (
    jid int PRIMARY KEY,
    raw json NOT NULL
);

CREATE TABLE lookup_data.locations (
    eva int PRIMARY KEY,
    name text NOT NULL,
    x int NOT NULL,
    y int NOT NULL,
    z int
);
CREATE TABLE lookup_data.operators (
    name text PRIMARY KEY
);
CREATE TABLE lookup_data.train_types (
    cat_code int NOT NULL,
    cat_out text NOT NULL,
    PRIMARY KEY (cat_code, cat_out)
);
CREATE TYPE lookup_data.operation_dates AS (
    dates date[],
    from_loc int,
    to_loc int,
    info text
);
CREATE TYPE lookup_data.scheduled_stop AS (
    eva int,
    scheduled_arrival time,
    scheduled_departure time
);
CREATE TABLE lookup_data.trips (
    jid int PRIMARY KEY,
    op_days lookup_data.operation_dates[] NOT NULL, 
    cat_code smallint NOT NULL,
    cat_out text NOT NULL,
    FOREIGN KEY (cat_code, cat_out) REFERENCES lookup_data.train_types (cat_code, cat_out),
    name text NOT NULL,
    route text NOT NULL,
    id int NOT NULL,
    admin text NOT NULL,
    operator text REFERENCES lookup_data.operators (name),
    stops lookup_data.scheduled_stop[] NOT NULL
);

CREATE TABLE lookup_data.location_counts (
    eva int REFERENCES lookup_data.locations (eva),
    cat_code smallint NOT NULL,
    cat_out text NOT NULL,
    FOREIGN KEY (cat_code, cat_out) REFERENCES lookup_data.train_types (cat_code, cat_out),
    PRIMARY KEY (eva, cat_code, cat_out),
    name text NOT NULL,
    count int NOT NULL
);


CREATE FUNCTION lookup_data.get_evas(lookup_data.scheduled_stop[]) RETURNS int[] AS
$func$
    SELECT array_agg(vals)
    FROM (select (unnest($1)).eva as vals) AS stop_evas;
$func$ LANGUAGE sql STABLE;
</code></pre>
</details>
<p>The whole database is currently contained to the lookup_data scheme.</p>
<p>The common scheme is shown above, with a few custom composite types and functions explained here:</p>
<ul>
<li><code>operation_dates</code> is a type that contains an array of <code>dates</code>, a <code>from_loc</code> eva with corresponding <code>to_loc</code> eva and a <code>info</code> text.</li>
<li><code>scheduled_stop</code> is a type describing a stop of a trip at a station. It contains the <code>eva</code>, the <code>scheduled_arrival</code> time and corresponding <code>scheduled_departure</code> time.</li>
<li><code>from_evas</code> is a function taking an array of <code>scheduled_stop</code> elements, extracting only the <code>eva</code> as int array from it.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="future-of-the-project"><a class="header" href="#future-of-the-project">Future of the project</a></h1>
<h2 id="future-of-the-project-1"><a class="header" href="#future-of-the-project-1">Future of the project</a></h2>
<p>I plan to continue my work on this project and maybe one day develop a good HAFAS library for Rust. This is the primary goal for the future, after which I plan to create a public API that serves better readable responses than HAFAS.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
