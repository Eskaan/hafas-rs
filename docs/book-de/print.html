<!DOCTYPE HTML>
<html lang="de" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>hafas-rs documentation</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="about.html"><strong aria-hidden="true">1.</strong> Über</a></li><li class="chapter-item expanded "><a href="goals.html"><strong aria-hidden="true">2.</strong> Ziele</a></li><li class="chapter-item expanded "><a href="structure.html"><strong aria-hidden="true">3.</strong> Struktur</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="hafas-wrap.html"><strong aria-hidden="true">3.1.</strong> hafas_wrap</a></li><li class="chapter-item expanded "><a href="database-cli.html"><strong aria-hidden="true">3.2.</strong> database_cli</a></li></ol></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">4.</strong> Intallation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="usage.html"><strong aria-hidden="true">4.1.</strong> Nutzung</a></li></ol></li><li class="chapter-item expanded "><a href="hafas.html"><strong aria-hidden="true">5.</strong> HAFAS & DB</a></li><li class="chapter-item expanded "><a href="future.html"><strong aria-hidden="true">6.</strong> Zukunft</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">hafas-rs documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/eskaan/hafas-rs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="hafas-rs"><a class="header" href="#hafas-rs">HAFAS-RS</a></h1>
<h3 id="entwicklung-eines-in-rust-geschriebenen-programms-zur-abfrage-von-deutsche-bahn-daten"><a class="header" href="#entwicklung-eines-in-rust-geschriebenen-programms-zur-abfrage-von-deutsche-bahn-daten">Entwicklung eines in Rust geschriebenen Programms zur Abfrage von &quot;Deutsche Bahn&quot;-Daten</a></h3>
<h2 id="hintergrund"><a class="header" href="#hintergrund">Hintergrund</a></h2>
<p>Die <a href="https://www.bahn.de/">Deutsche Bahn AG</a> (kurz DB oder auch die Bahn) ist das staatliche Eisenbahnunternehmen Deutschlands. Die DB ist
eines der größten Transportunternehmen der Welt und der größte Eisenbahnbetreiber in
Europa (laut <a href="https://web.archive.org/web/20170927052239/http://www.railway-technology.com/features/featureengines-of-trade-the-ten-biggest-rail-companies-by-revenue-4943955/featureengines-of-trade-the-ten-biggest-rail-companies-by-revenue-4943955-1.html">dieser</a> Quelle), wobei ein komplexes Netzwerk aus Fahrplänen, Zügen und Strecken in Deutschland und andere
Europäische Länder müssen organisiert werden müssen. Zur Erleichterung der Online-Fahrplanauskunft 
wird die Software <a href="https://de.wikipedia.org/wiki/HAFAS">HAFAS</a> (HaCon Fahrplan-Auskunfts-System) der Firma HaCon
(Hannover Consulting, gehörend zu Siemens) verwendet.
<a href="https://www.rust-lang.org/">Rust</a> ist eine System-Programmiersprache mit hervorragender Leistung und Sicherheit.
Es ist nicht erforderlich, einen Müllsammler<sup class="footnote-reference"><a href="#gc">1</a></sup> oder Referenzzählung<sup class="footnote-reference"><a href="#refc">2</a></sup> zu verwenden, um die Speichersicherheit<sup class="footnote-reference"><a href="#memsafety">3</a></sup> sicherzustellen.
Sicherheit. Rust kann für die Systemprogrammierung verwendet werden und bietet gleichzeitig High-Level-Funktionen.
Beispielsweise können mit Rust Programme erstellt werden, um Daten aus unterschiedlichsten Programmierschnittstellen<sup class="footnote-reference"><a href="#apis">4</a></sup> zu ziehen, z.B.
HAFAS.</p>
<h2 id="dokumentation"><a class="header" href="#dokumentation">Dokumentation</a></h2>
<p>Der empfohlene Zugriff auf die Dokumentation erfolgt über die generierte HTML-Version im Ordner <code>docs</code>.
Es gibt sowohl eine <code>rustdoc</code>- als auch eine <code>mdbook</code>-Dokumentation zu diesem Projekt, die sich im Ordner <code>docs</code> befindet.</p>
<ul>
<li><a href="https://eskaan.github.io/hafas-rs/rustdoc/database_cli/index.html">Rustdoc</a></li>
<li><a href="https://eskaan.github.io/hafas-rs/book/">[en] Buch</a></li>
<li><a href="https://eskaan.github.io/hafas-rs/book-de/">[de] Buch</a></li>
</ul>
<h2 id="Über-das-projekt"><a class="header" href="#Über-das-projekt">Über das Projekt</a></h2>
<p>Das Zeil dieses Projekts mit dem Namen HAFAS-RS, für eine Highschool-Präsentation (GFS) von Adrian Struwe
(<a href="https://github.com/eskaan">Eskaan</a>) erstellt, war ein Programm zu entwickeln, um gezielt Daten zu Fahrten, Zugtypen, Standorten und Betreibern der Deutschen Bahn zu sammeln und aufzulisten.</p>
<p>Es ist derzeit unter der <a href="https://www.gnu.org/licenses/gpl-3.0.txt">GPL3</a>-Lizenz lizenziert, die eine offene Verteilung und Änderung des Codes erlaubt.
Das Projekt ist vollständig dokumentiert, sowohl im Quellcode (per <a href="doc.rust-lang.org/rustdoc">rustdoc</a>) als auch in diesem <a href="rust-lang.github.io/mdBook">mdbook</a>.</p>
<div class="footnote-definition" id="gc"><sup class="footnote-definition-label">1</sup>
<p>Englisch <a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">Garbage Collector</a>
<sup class="footnote-reference"><a href="#refc">2</a></sup>: Englisch <a href="https://en.wikipedia.org/wiki/Reference_counting">Reference Counting</a>
<sup class="footnote-reference"><a href="#memsafety">3</a></sup>: Englisch <a href="https://en.wikipedia.org/wiki/Memory_safety">Memory Safety</a>
<sup class="footnote-reference"><a href="#apis">4</a></sup>: Englisch <a href="https://en.wikipedia.org/wiki/API">API</a>, Application Programming Interface</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ziele"><a class="header" href="#ziele">Ziele</a></h1>
<p>Das primäre Ziel des Projekts war die Extrahierung von Daten, z.B. die meistgenutzten Stationen und sie in einer Datenbank anzuzeigen.</p>
<p>Ein weiteres Ziel war die Abfrage und der Vergleich von Zugfahrplänen zu Echtzeitdaten. 
Leider wurde mir nach vielen Experimenten klar, dass diese API entwickelt wurde, um solchen Datenerfassungsversuchen zu widerstehen.</p>
<p>In Zukunft möchte ich versuchen, einen praktikablen Weg zu finden (der die API nicht überlastet), um solche Daten zu sammeln.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="projektstruktur"><a class="header" href="#projektstruktur">Projektstruktur</a></h1>
<h2 id="allgemeine-struktur"><a class="header" href="#allgemeine-struktur">Allgemeine Struktur</a></h2>
<p>Das Projekt gliedert sich in zwei Hauptteile:</p>
<ul>
<li>
<p><a href="./hafas-wrap.html">hafas-wrap</a>, die Bibliothek<sup class="footnote-reference"><a href="#lib">1</a></sup> für den Zugriff auf HAFAS<sup class="footnote-reference"><a href="#hafas">2</a></sup>.</p>
<p>Es bietet einfache Möglichkeiten, über mehrere Methoden auf das HAFAS zuzugreifen
und ein generisches Typsystem, das auch benutzerdefinierte Anforderungs- und Antworttypen außerhalb der allgemeinen Verwendung unterstützt.</p>
</li>
<li>
<p><a href="./Datenbank-Cli.html">database-cli</a>, das über die Bibliothek abgefragte Daten verwendet und bestimmte Teile zur weiteren Verarbeitung in eine Postgresql-Datenbank einfügt.</p>
<p>Es enthält derzeit auch die Unterbefehle zum ausgeben eines Diagramms mit den am häufigsten verwendeten Stationen in der Datenbank.
<strong>Wenn Sie nach der Nutzung dieses Projekts suchen, müssen Sie hier nachsehen.</strong></p>
</li>
</ul>
<p>Der größte Teil des Projekts, wenn auch nicht alles, ist in einem prozedualen Stil geschrieben, da dieses Programm auf einem CLI und einer entsprechenden Bibliothek basiert.
Es gibt mehr objektorientierte Teile in der Bibliothek.</p>
<h2 id="weitere-dokumentation"><a class="header" href="#weitere-dokumentation">Weitere Dokumentation</a></h2>
<p>Jeder dieser Projektteile enthält seine eigene <code>README.md</code>-Datei, die seine Verwendung weiter erklärt.</p>
<p>Ich empfehle auch, die englische rust-doc Dokumentation für die Dokumentation auf Projektebene zu verwenden, die im Ordner <code>docs/rustdoc</code> <a href="/rustdoc/database_cli/index.html"><code>./docs/rustdoc/database_cli/index.html</code></a> ist.</p>
<div class="footnote-definition" id="lib"><sup class="footnote-definition-label">1</sup>
<p>Englisch Library, in Rust auch Crate genannt.
<sup class="footnote-reference"><a href="#hafas">2</a></sup>: Hacon Fahrplan Auskunfts System</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="die-hafas_wrap-bibliothek"><a class="header" href="#die-hafas_wrap-bibliothek">Die hafas_wrap-Bibliothek</a></h1>
<p>Die Hauptfunktionalität kommt mit dem <code>Client</code>-Objekt, da alle Anfragen damit erledigt werden.</p>
<p>Diese Bibliothek stellt auch einige Profile (<a href="hafas-wrap.html#hafas-profiles"><code>hafas_profiles</code></a>) für gängige Endpunkte und <a href="hafas-wrap.html#methods">Anfrage- und Antwortstrukturen</a> bereit, um die Arbeit mit HAFAS-Endpunkten zu vereinfachen.
Das Modul <a href="hafas-wrap.html#utils"><code>util</code></a> bietet Funktionen zum De- und Codieren von Base64-AES-Strings unter Verwendung eines statisch festgelegten Schlüssels und einer md5-Hashing-Funktion, die für Anfragen benötigt werden.</p>
<h2 id="die-anfragefunktion"><a class="header" href="#die-anfragefunktion">Die Anfragefunktion</a></h2>
<p>Es bietet ein einfaches, anpassbares System für den Zugriff auf HAFAS<sup class="footnote-reference"><a href="#hafas">1</a></sup>.
Es gibt drei allgemeine Anforderungsparameter:</p>
<pre><code class="language-rust ignore">    pub async fn request&lt;I: Serialize + Sized, O: DeserializeOwned&gt;(
        &amp;self,
        profile: &amp;HafasProfile,
        requests: Vec&lt;RawHafasRequest&lt;I&gt;&gt;,
    ) -&gt; Result&lt;Vec&lt;O&gt;, RequestError&gt; {</code></pre>
<ul>
<li>
<p>Ein Verweis auf sich selbst, um auf den Anfrageclient <a href="https://crates.io/crates/reqwest">reqwest</a> zuzugreifen, der zum Stellen von Webanfragen verwendet wird</p>
</li>
<li>
<p>Ein Verweis auf eine Instanz des Typs <code>HafasProfile</code>.</p>
<p>Ein <code>HafasProfile</code> spezifiziert den Endpunkt, eine mögliche Verschlüsselung und zusätzliche Konfigurationsdaten, die mit der Anfrage übergeben werden müssen</p>
</li>
<li>
<p>Ein Array, das Instanzen des Typs <code>RawHafasRequest</code> enthält</p>
<p>Der <code>RawHafasRequest</code>-Typ (und seine generische Anfrage) müssen <code>serde::Serialize + Send</code> implementieren.
Diese Implementierungen werden benötigt, damit der Typ in eine JSON-Zeichenfolge serialisiert werden kann, die in der POST-Anfrage an HAFAS<sup class="footnote-reference"><a href="#hafas">1</a></sup> verwendet wird.</p>
</li>
</ul>
<p>Die <code>request</code>-Funktion versucht auch, die resultierenden Request-Bodys in den spezifizierten generischen Typ <code>O</code> zu parsen.
Dieser Typ muss <code>DeserializeOwned</code> implementieren, damit er von einem JSON-Objekt deserialisiert werden kann.</p>
<h2 id="anfrageverfahren"><a class="header" href="#anfrageverfahren">Anfrageverfahren</a></h2>
<p>Es gibt zwei Methoden zum Anfordern von Daten: Entweder <code>request</code> oder <code>request_raw</code>,
wobei <code>request</code> hauptsächlich ein Wrapper um die <code>request_raw</code>-Methode ist, um das Parsen der Ergebnisse zu erleichtern.</p>
<p>Hier ist eine Zusammenfassung dessen, was die Funktionen tun:</p>
<p>Beide:</p>
<ol>
<li>
<p>Kopieren des <code>HafasProfile</code> in ein JSON-Objekt,</p>
<p>Serialisieren der Anfragen in ein JSON-Objekt und setzen des <code>svcReqL</code>-Wert der Anfrage darauf.</p>
<p>Serialisieren des JSON-Objekt in einen String</p>
<pre><code class="language-rust ignore">    let mut req_values = profile.config.clone();
    req_values[&quot;svcReqL&quot;] = serde_json::to_value(&amp;requests).unwrap();
    let req_string = serde_json::to_string(&amp;req_values)?;</code></pre>
</li>
<li>
<p>Optional das erstellen einer Prüfsumme für die GET-Parameter der Anfrage.</p>
<pre><code class="language-rust ignore">    let checksum = match &amp;profile.secret {
        Some(secret) =&gt; util::hash_md5(&amp;(req_string.clone() + secret)),
        None =&gt; String::new(),
    };</code></pre>
</li>
<li>
<p>Antworttext einer Webanfrage an HAFAS<sup class="footnote-reference"><a href="#hafas">1</a></sup> erstellen, senden und abwarten.</p>
<pre><code class="language-rust ignore">    let response = self
        .reqwest_client
        .post(profile.url)
        .header(&quot;Accept&quot;, &quot;application/json&quot;)
        .header(&quot;Content-Type&quot;, &quot;application/json&quot;)
        .query(&amp;[(&quot;checksum&quot;, &amp;checksum)])
        .body(req_string)
        .send()
        .await?;</code></pre>
</li>
</ol>
<p><code>request_raw</code> gibt an dieser Stelle den Antwort-String zurück, während <code>request</code> mit dem Parsen der Antwort fortfährt:</p>
<p>Nur <code>Anfrage</code>:</p>
<ol start="5">
<li>
<p>Prüft, ob HAFAS<sup class="footnote-reference"><a href="#hafas">1</a></sup> eine Fehlermeldung zurückgegeben hat.</p>
<pre><code class="language-rust ignore">    if res.get(&quot;err&quot;) != Some(&amp;Value::String(String::from(&quot;OK&quot;))) {
        return Err(RequestError::InternalError(
            res.get(&quot;err&quot;)</code></pre>
</li>
<li>
<p>Deserialisiert die Anfrage in ein JSON-Objekt und versucht, das Antworttextsegment als Array abzurufen.</p>
<pre><code class="language-rust ignore">    res.get(&quot;svcResL&quot;)
        .ok_or(RequestError::DeserializeError(
            &quot;Response not an Object or svcResL does not exist in it.&quot;,
        ))?
        .as_array()
        .ok_or(RequestError::DeserializeError(&quot;svcResL is not an array.&quot;))?</code></pre>
</li>
<li>
<p>Deserialisiert den Array von JSON-Objekten in den angegebenen generischen Typ <code>O</code>.</p>
<pre><code class="language-rust ignore">        .iter()
        .map(|r| {
            Ok(serde_json::from_value(
                r.get(&quot;res&quot;)
                    .ok_or(RequestError::DeserializeError(
                        &quot;field res does not exist. This is most likely a request error.&quot;,
                    ))?
                    .clone(),
            )?)
        })
        .collect::&lt;Result&lt;Vec&lt;O&gt;, RequestError&gt;&gt;()</code></pre>
</li>
</ol>
<h2 id="hafas-profile"><a class="header" href="#hafas-profile">HAFAS-Profile</a></h2>
<p>Im Modul <code>hafas_profiles</code> sind mehrere Konfigurationsvoreinstellungen für verschiedene HAFAS<sup class="footnote-reference"><a href="#hafas">1</a></sup>-Endpunkte zu finden.</p>
<p>Diese wurden aus verschiedenen anderen Open-Source-Projekten gesammelt.</p>
<h2 id="methoden"><a class="header" href="#methoden">Methoden</a></h2>
<p>Im Modul <code>Methoden</code> finden Sie einige Voreinstellungen für Request- und Response-Strukturen. Man muss sie nicht verwenden, aber sie wurden getestet und scheinen für die meisten Endpunkte zu funktionieren.</p>
<p>Derzeit verfügbare Methoden:</p>
<ul>
<li>HimSearch</li>
<li>JourneyMatch</li>
<li>Reisedetails</li>
</ul>
<h2 id="dienstprogramme"><a class="header" href="#dienstprogramme">Dienstprogramme</a></h2>
<p>Einige verschiedene Funktionen wie AES-Verschlüsselung mit einem festgelegten Schlüssel oder das Hashen eines Strings mit dem <code>md5</code>-Digest-Algorithmus.</p>
<div class="footnote-definition" id="hafas"><sup class="footnote-definition-label">1</sup>
<p><a href="https://de.wikipedia.org/wiki/HAFAS">Hacon Fahrplan Auskunfts System</a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="die-datenbank-cli-toolchain"><a class="header" href="#die-datenbank-cli-toolchain">Die Datenbank-CLI-Toolchain</a></h1>
<p>Dies ist derzeit die einzige Implementierung der oben genannten Bibliothek.</p>
<p>Die aktuelle Verwendung besteht darin, eine Datenbank mit Fahrten, Zugtypen, Standorten und Betreibern zu erstellen.
Das genaue Layout findet man unter <code>database_layout.png</code> im Stammverzeichnis des Projekts.
Man kann auch ein einfaches Diagramm aus Nutzungsstatistiken erstellen.</p>
<p>Obwohl das Programm keine Live-Datenbank zum Kompilieren benötigt, benötigt es eine Postgres-Datenbank, um zu funktionieren.
Die Datenbank muss auf localhost liegen, mit dem Namen <code>db-statistics</code> und dem Benutzer <code>postgres</code> (passwortlos)
auf alle Tabellen zugreifen zu können, die im Datenbanklayout angegeben sind.
Um die Datenbank für die Verwendung vorzubereiten, führen Sie <code>database-climigrate</code> aus. Dadurch werden alle erforderlichen Schemas, Tabellen, Typen und Funktionen erstellt.</p>
<p>Die genaue Verwendung finden Sie in der Rustdoc-Dokumentation der Methode [<code>main</code>] oder im Abschnitt über die Nutzung im Buch.
Diese Crate ist größtenteils in einem prozeduraleren (aber auch teilweise objektorientierten) Programmierstil geschrieben, wie es für eine CLI-Schnittstelle zu einer Bibliothek üblich ist.
Daraus resultieren viele Module, die meist einzelne Funktionen anstelle ganzer Objekte enthalten.</p>
<p>Für die Modulebene empfehle ich wieder die Rust-Doc-Dokumentation für diese Crate, die <a href="./databasecli/index.html">hier</a> verfügbar ist.</p>
<p>Besser strukturierte Informationen zu den CLI-Befehlen finden Sie in der <a href="./usage.html">Nutzungssektion</a> dieses Buchs.</p>
<h2 id="main"><a class="header" href="#main">Main</a></h2>
<p>Dies ist das Wurzelmodul<sup class="footnote-reference"><a href="#root">1</a></sup> der Crate, hier liegt die Funktion, die beim Programmstart aufgerufen wird. Dieses Modul analysiert die CLI-Argumente und ruft die entsprechenden Funktionen auf.</p>
<p>##request_raw_jids
Dieses Modul ist für den Unterbefehl <code>data request_raw</code> verantwortlich. Es fordert Rohdaten von HAFAS an und schreibt sie in die Tabelle <code>raw_data</code>.</p>
<h2 id="parse_raw_jids"><a class="header" href="#parse_raw_jids">parse_raw_jids</a></h2>
<p>Dieses Modul wird vom Unterbefehl <code>data parse</code> aufgerufen und analysiert Daten aus den <code>raw_data</code> und fügt sie in die anderen Tabellen <code>trips</code>, <code>locations</code>, <code>operators</code> und <code>train_types</code> ein.</p>
<h2 id="count_location_trips"><a class="header" href="#count_location_trips">count_location_trips</a></h2>
<p>Dieses Modul ist eine Erweiterung des Unterbefehls <code>data parse</code>, der mit <code>dara parse_heatmap</code> aufgerufen wird.</p>
<h2 id="vergleiche_rohdaten"><a class="header" href="#vergleiche_rohdaten">vergleiche_rohdaten</a></h2>
<p>Dieses Modul wird vom Unterbefehl &quot;Datenprüfung&quot; aufgerufen. Es verwendet das Modul <code>request_raw_jids</code>, um ein einzelnes JID anzufordern und es mit der Tabelle <code>raw_data</code> zu vergleichen.</p>
<h2 id="create_heatmap_diagram"><a class="header" href="#create_heatmap_diagram">create_heatmap_diagram</a></h2>
<p>Dieses Modul enthält neben dem Herumspielen mit Datenbankdaten den einzigen praktischen Nutzen, den ich bisher gefunden habe. Es wird vom Unterbefehl <code>create_heatmap</code> aufgerufen und erstellt ein horizontales Diagramm, das die am häufigsten verwendeten Stationen in der Datenbank anzeigt.</p>
<div class="footnote-definition" id="root"><sup class="footnote-definition-label">1</sup>
<p>Englisch Root Module, in Java die Klasse mit main Funktion.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<h2 id="abhängigkeiten"><a class="header" href="#abhängigkeiten">Abhängigkeiten</a></h2>
<p>Dieses Programm ist abhängig von:</p>
<ul>
<li>Ein laufender <a href="https://www.postgresql.org/">Postgresql</a>-Server auf <code>postgres://postgres@localhost/db-statistics</code> <br>
Getestet mit Postgresql 13</li>
<li>Stabile version von <a href="https://www.rust-lang.org/">Rust</a></li>
<li>Eine funktionierende Internetverbindung</li>
</ul>
<h2 id="schnellstartanleitung"><a class="header" href="#schnellstartanleitung">Schnellstartanleitung</a></h2>
<p>Information: Der größte Teil dieser Anleitung funktioniert nur unter Linux. Weitere Informationen zu anderen Systemen finden Sie in der <a href="https://www.postgresql.org/docs/current/">Postgresql-Dokumentation</a> und auf der <a href="https://www.rust-lang.org/">Rust</a>-Website.</p>
<ol>
<li>Zuerst müssen Sie <a href="https://www.postgresql.org/">postgresql</a> installieren:
<ol>
<li>Installieren Sie das Datenbankpaket auf Ihrem System:
<ul>
<li>Arch: <code>sudo pacman -S postgresql</code></li>
<li>Debain &amp; Ubuntu: <code>sudo apt install postgresql</code></li>
<li>Sonstige: <a href="https://www.postgresql.org/docs/current/tutorial-install.html">Postgresql-Installationsanleitung</a></li>
</ul>
</li>
<li>Melden Sie sich dann bei dem neu erstellten Benutzer an: <code>sudo su postgres</code></li>
<li>Erstellen Sie einen neuen Datenbank-Cluster mit <code>initdb -D Verzeichnis/to/store/data</code>.</li>
<li>Erstellen Sie im Cluster eine neue Datenbank mit dem Namen db-statistics im Cluster: <code>createdb db-statistics</code></li>
<li>Starten Sie den Postgresql-Server (normalerweise <code>sudo systemctl start postgresql</code>)</li>
</ol>
</li>
<li>Kompilieren Sie das Projekt:
<ol>
<li>Installieren Sie das Rustup-Paket:
<ul>
<li>Arch: <code>sudo pacman install rustup</code></li>
<li>Debial &amp; Ubuntu: <code>sudo apt install rustup</code></li>
<li>Sonstige: <a href="https://rustup.rs/">Rustup-Installationsanleitung</a></li>
</ul>
</li>
<li>Führen Sie <code>rustup install stable</code> in Ihrem Terminal aus.</li>
<li>Führen Sie <code>cargo build --release</code> im hafas-rs-Ordner aus.
Dadurch sollte ein Ordner mit dem Namen <code>target/release</code> erstellt werden, der eine ausführbare Datei mit dem Namen <code>database-cli</code> enthält.
Herzlichen Glückwunsch, Sie haben das Projekt gerade erfolgreich kompiliert!</li>
</ol>
</li>
<li>Verwenden Sie dann <code>database-cli migrate</code>, um die Verbindung zur lokalen Datenbank zu überprüfen und die notwendige Infrastruktur wie Schemas, Tabellen und Funktionen zu erstellen.</li>
<li>Verwenden Sie <code>database-cli data request_raw 2000000 --parse</code>, um Daten anzufordern und in die Datenbank zu parsen.
Es wird eine Weile dauern, bis alle ~1,5 Millionen Einträge abgerufen sind.
Ich empfehle, diesen Befehl über Nacht oder zu anderen Zeiten in denen HAFAS nicht stark ausgelastet ist auszuführen.</li>
<li>Sie sind bereit, mit den Daten in Ihrer bevorzugten SQL-Eingabeaufforderung zu spielen! Weitere Informationen zur Datenbankstruktur finden Sie im <a href="./hafas.html">HAFAS-Abschnitt</a>.</li>
</ol>
<p>(Optional)</p>
<ol start="6">
<li>
<p>Verwenden Sie <code>database-cli data parse_heatmap</code>, um die Eva<sup class="footnote-reference"><a href="#eva">1</a></sup>-Zählungen der Reise in ein leichteres Format zu parsen.</p>
</li>
<li>
<p>Verwenden Sie <code>database-cli create_heatmap -m 10</code>, um ein Diagramm der 10 am häufigsten verwendeten Stationen zu erhalten.</p>
<p>Nachdem Sie diese Schritte ausgeführt haben, sollte das Programm ein Bild mit dem Namen <code>heatmap.svg</code> im aktuellen Ordner erstellen. Hier ist ein Beispiel dafür:
<img src="./images/heatmap.svg" alt="Heatmap-Diagramm" /></p>
</li>
</ol>
<div class="footnote-definition" id="eva"><sup class="footnote-definition-label">1</sup>
<p><a href="https://de.wikipedia.org/wiki/Interne_Bahnhofsnummer">Internationale Bahnhofsnummer</a></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="verwendung"><a class="header" href="#verwendung">Verwendung</a></h1>
<p>Wie der Name der Crate schon sagt, kompiliert <code>database-cli</code> in ein Kommandozeilenprogramm<sup class="footnote-reference"><a href="#cli">1</a></sup>.
Diese Schnittstelle arbeitet mit einer Postgresql-Datenbank zusammen, um HAFAS-Daten zu speichern und anzufordern.</p>
<h2 id="liste-der-unterbefehle"><a class="header" href="#liste-der-unterbefehle">Liste der Unterbefehle:</a></h2>
<p>Alle Befehle können mit -v oder -vv übergeben werden, um sie ausführlicher zu machen.
Das Argument <code>--help</code> kann zu jedem Unterbefehl hinzufügt werden, um Details zu den Argumenten anzuzeigen.
Wenn Sie die CLI nicht kompilieren möchten, finden Sie Argumente im Quellcode.</p>
<details>
<summary>Verantwortlicher Code in `main.rs - zum Erweitern klicken`</summary>
<pre><code class="language-rust ignore">    // Setup clap with subcommands
    let mut cmd = command!(&quot;Hafas Scraping Database Tools&quot;)
        .arg(arg!(-v --verbose... &quot;Verbose output. Specify twice for trace mode&quot;))
        .arg(arg!(-q --quiet &quot;Only print on error and warnings&quot;))
        .subcommands(&amp;[
            command!(&quot;data&quot;)
                .about(&quot;Lookup and schedule data management&quot;)
                .subcommands(&amp;[
                    command!(&quot;request_raw&quot;)
                        .about(&quot;Request raw schedule data&quot;)
                        .args(&amp;[
                            arg!(&lt;TO&gt; &quot;Stop at jid&quot;).value_parser(value_parser!(usize)),
                            arg!([FROM] &quot;Begin with jid, defaults to 0&quot;)
                                .value_parser(value_parser!(usize)),
                            arg!(-u --update &quot;Also request existing entries&quot;),
                            arg!(-c --continue &quot;Continue at current highes jid&quot;),
                            arg!(-p --parse &quot;Synchronously parse using `data parse`&quot;),
                            arg!(-s --&quot;chunk-size&quot; &lt;SIZE&gt; &quot;Chunk size of requests. Defaults to 100&quot;).value_parser(value_parser!(usize)),
                        ]),
                        command!(&quot;parse&quot;)
                            .about(&quot;Parse raw data to schedule and stop data.&quot;)
                            .args(&amp;[
                                arg!([FROM] &quot;Begin with jid, defaults to 0&quot;).value_parser(value_parser!(i32)),
                                arg!([TO] &quot;Stop at jid&quot;).value_parser(value_parser!(i32)),
                                arg!(-s --&quot;chunk-size&quot; &lt;SIZE&gt; &quot;Chunk size of requests. Defaults to 100&quot;).value_parser(value_parser!(i32)),
                        ]),
                        command!(&quot;parse_heatmap&quot;)
                            .about(&quot;Parse trip data to heatmap counts.&quot;),
                        command!(&quot;check&quot;)
                        .about(&quot;Check if a single jid is different to the remote data.&quot;).arg(arg!(&lt;jid&gt; &quot;jid to check on&quot;).value_parser(value_parser!(usize))),
                ]),
                command!(&quot;create_heatmap&quot;)
                .about(&quot;Create heatmap diagram from parsed data.&quot;)
                .args(&amp;[
                    arg!([FILE] &quot;Output file to use. Defaults to ./heatmap.svg&quot;),
                    arg!(-m --max &lt;SIZE&gt; &quot;Maximum entries to display&quot;).value_parser(value_parser!(usize)),
                    arg!(-c --&quot;filter-cat-code&quot; &lt;CAT_CODE&gt; &quot;Filter results by cat code&quot;).value_parser(value_parser!(u8)),
                    arg!(-o --&quot;filter-cat-out&quot; &lt;CAT_OUT&gt; &quot;Filter results by cat out (f.e. RE, ICE)&quot;),
                    arg!(-s --&quot;limit-search&quot; &lt;SIZE&gt; &quot;Maximum search results to query&quot;).value_parser(value_parser!(i64)),
                ]),
            //command!(&quot;status&quot;).about(&quot;Query database status&quot;),
            command!(&quot;migrate&quot;).about(&quot;Migrate/create database&quot;),
        ]);</code></pre>
</details>
<ul>
<li>
<p><code>data</code> Dieser Befehl kann nur zusammen mit einem seiner Unterbefehle verwendet werden, er hat keine eigenen Eigenschaften.
Es sammelt im Allgemeinen Befehle, die verwendet werden, um Suchdaten für Zugfahrten in der Datenbank zu verschieben.</p>
<ul>
<li>
<p><code>request_raw</code>: Dieser Befehl fordert rohe Fahrplandaten über alle JIDs im HAFAS-Endpunkt an.
Unabhängig vom <code>TO</code>-Argument gerät der Befehl in Panik, wenn er das letzte Jid erreicht.
Der übliche letzte Jid liegt bei etwa 1,5 Millionen.</p>
<p>Dies ist normalerweise der zweite Befehl, der nach <code>migrate</code> ausgeführt wird.</p>
<p>Es ist zu beachten, dass dieser Befehl abhängig von Ihrem Computer und Ihrer Netzwerkverbindung normalerweise ziemlich lange dauert, bis er fertig ist.
Es wird empfohlen, obwohl es nicht notwendig ist, es mit <code>--parse</code> aufzurufen.</p>
<p>Es wird empfohlen, alle anderen optionalen Flags auf einem Standardwert zu belassen, um ein Timeout zu verhindern.</p>
</li>
<li>
<p><code>parse</code>: Dieser Befehl parst die Daten aus der <code>raw_data</code>-Tabelle in ein verwendbares Format und fügt sie in die anderen Tabellen ein.
Es kann auch automatisch aufgerufen werden, indem <code>--parse</code> zu den Argumenten von <code>request_raw</code> hinzugefügt wird.</p>
<p>Sie können sich das Datenbankschema und hauptsächlich den [Hafas-Abschnitt] (./hafas.html) ansehen, um weitere Details darüber zu erhalten, wie Daten geparst werden.</p>
</li>
<li>
<p><code>parse_heatmap</code>: Dieser Befehl sollte zu einem bestimmten Zeitpunkt aufgerufen werden, bevor die Funktion <code>create_heatmap</code> verwendet wird.
Es zählt alle aufgezeichneten Zugfahrten in einer eigenen Tabelle für einen schnelleren Zugriff zusammen.</p>
<p>Da naher und lokaler Verkehr das Endbild verschleiern kann, empfehle ich, <code>-o 'ICE'</code> als Filter zu setzen.</p>
</li>
<li>
<p><code>check</code>: Dieser Befehl prüft, ob Daten vom HAFAS-Endpunkt von den aktuellen Daten abweichen.
Diese Prüfung wird nur für einen einzigen Jid durchgeführt. Ein Unterschied könnte auf eine Fahrplanänderung hindeuten.</p>
</li>
</ul>
</li>
<li>
<p><code>create_heatmap</code> Erstellt ein horizontales Balkendiagramm der am häufigsten verwendeten Stationen in der Nachschlagetabelle.
Es kann nach cat_code, cat_out und Suchlimit gefiltert werden. Aus derzeit unbekannten Gründen bringt alles über 11 Balken die Stationsnamen durcheinander.</p>
</li>
<li>
<p><code>migrate</code>: Erstellt die gesamte notwendige Infrastruktur auf der entfernten Datenbank. Das CLI selbst arbeitet derzeit nur mit dem lookup_data-Schema, aber dieses <code>sqlx</code>-Feature benötigt</p>
</li>
</ul>
<p>Die meisten Befehle führen zu einem Fortschrittsbalken wie diesem:
<img src="./images/progress_bar.png" alt="Fortschrittsbalken" /><br>
Die Zählungen am Ende sollen einen ungefähren Hinweis darauf geben, wie lange der Befehl dauern wird.</p>
<div class="footnote-definition" id="cli"><sup class="footnote-definition-label">1</sup>
<p>Englisch <a href="https://en.wikipedia.org/wiki/Command-line_interface">CLI</a>, Command Line Interface</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hafas-und-datenbanklayout"><a class="header" href="#hafas-und-datenbanklayout">HAFAS und Datenbanklayout</a></h1>
<h2 id="datenbanklayout"><a class="header" href="#datenbanklayout">Datenbanklayout</a></h2>
<p><img src="./images/db_layout.png" alt="Layout" /></p>
<details>
<summary>DDL für Datenbanklayout - zum Erweitern klicken</summary>
<pre><code class="language-SQL">CREATE SCHEMA lookup_data;

CREATE TABLE lookup_data.raw_data (
    jid int PRIMARY KEY,
    raw json NOT NULL
);

CREATE TABLE lookup_data.locations (
    eva int PRIMARY KEY,
    name text NOT NULL,
    x int NOT NULL,
    y int NOT NULL,
    z int
);
CREATE TABLE lookup_data.operators (
    name text PRIMARY KEY
);
CREATE TABLE lookup_data.train_types (
    cat_code int NOT NULL,
    cat_out text NOT NULL,
    PRIMARY KEY (cat_code, cat_out)
);
CREATE TYPE lookup_data.operation_dates AS (
    dates date[],
    from_loc int,
    to_loc int,
    info text
);
CREATE TYPE lookup_data.scheduled_stop AS (
    eva int,
    scheduled_arrival time,
    scheduled_departure time
);
CREATE TABLE lookup_data.trips (
    jid int PRIMARY KEY,
    op_days lookup_data.operation_dates[] NOT NULL, 
    cat_code smallint NOT NULL,
    cat_out text NOT NULL,
    FOREIGN KEY (cat_code, cat_out) REFERENCES lookup_data.train_types (cat_code, cat_out),
    name text NOT NULL,
    route text NOT NULL,
    id int NOT NULL,
    admin text NOT NULL,
    operator text REFERENCES lookup_data.operators (name),
    stops lookup_data.scheduled_stop[] NOT NULL
);

CREATE TABLE lookup_data.location_counts (
    eva int REFERENCES lookup_data.locations (eva),
    cat_code smallint NOT NULL,
    cat_out text NOT NULL,
    FOREIGN KEY (cat_code, cat_out) REFERENCES lookup_data.train_types (cat_code, cat_out),
    PRIMARY KEY (eva, cat_code, cat_out),
    name text NOT NULL,
    count int NOT NULL
);


CREATE FUNCTION lookup_data.get_evas(lookup_data.scheduled_stop[]) RETURNS int[] AS
$func$
    SELECT array_agg(vals)
    FROM (select (unnest($1)).eva as vals) AS stop_evas;
$func$ LANGUAGE sql STABLE;
</code></pre>
</details>
<p>Die gesamte Datenbank ist derzeit im lookup_data-Schema enthalten.</p>
<p>Das allgemeine Schema ist oben dargestellt, mit einigen benutzerdefinierten zusammengesetzten Typen und Funktionen, die hier erklärt werden:</p>
<ul>
<li><code>operation_dates</code> ist ein Typ, der ein Array von <code>dates</code>, ein <code>from_loc</code>-Eva mit entsprechendem <code>to_loc</code>-Eva und einen <code>Info</code>-Text enthält.</li>
<li><code>scheduled_stop</code> ist ein Typ, der einen Halt einer Fahrt an einer Station beschreibt. Es enthält die <code>eva</code>, die <code>scheduled_arrival</code>-Zeit und die entsprechende <code>scheduled_departure</code>-Zeit.</li>
<li><code>from_evas</code> ist eine Funktion, die ein Array von <code>scheduled_stop</code>-Elementen verwendet und nur das <code>eva</code> als int-Array daraus extrahiert.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zukunft-des-projekts"><a class="header" href="#zukunft-des-projekts">Zukunft des Projekts</a></h1>
<p>Ich plane, meine Arbeit an diesem Projekt fortzusetzen und vielleicht eines Tages eine gute HAFAS-Bibliothek für Rust zu entwickeln. Dies ist das primäre Ziel für die Zukunft, danach plane ich, eine öffentliche API zu erstellen, die besser lesbare Antworten liefert als HAFAS.</p>
<p>Ich freue mich immer über Issues und Pull-Requests zu meinen Projekten. Wenn sich dieses Projekt durchsetzt, werde ich es sicherlich genießen, es zu pflegen.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
